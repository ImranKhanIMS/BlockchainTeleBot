"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.labelhash = exports.namehash = exports.isValidTld = exports.isValidDomain = exports.isValidLabel = exports.toChecksumAddress = exports.isValidChecksumAddress = exports.isValidAddress = exports.getCurrentAddress = exports.hasAccounts = exports.hasMethod = void 0;

var _ethEnsNamehash = require("eth-ens-namehash");

var _jsSha = require("js-sha3");

var rskjutils = _interopRequireWildcard(require("rskjs-util"));

var _constants = require("./constants");

var _types = require("./types");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

/**
 * Checks if the contract in the given address has the given method
 *
 * @param web3 - Web3 instance
 * @param contractAddress - address of the contract to check
 * @param signatureHash - keccak256 of the method signature
 *
 * @returns
 * true if method exists, false if not
 */
var hasMethod = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator(function* (web3, contractAddress, signatureHash) {
    var code = yield web3.eth.getCode(contractAddress);
    return code.indexOf(signatureHash.slice(2, signatureHash.length)) > 0;
  });

  return function hasMethod(_x, _x2, _x3) {
    return _ref.apply(this, arguments);
  };
}();
/**
 * Checks if the given web3 instance has accounts to sign txs
 *
 * @param web3 - Web3 instance
 *
 * @returns
 * true if has accounts, false if not
 */


exports.hasMethod = hasMethod;

var hasAccounts = /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator(function* (web3) {
    var accounts = [];

    try {
      accounts = yield web3.eth.getAccounts();
    } catch (_unused) {
      return false;
    }

    return accounts.length > 0;
  });

  return function hasAccounts(_x4) {
    return _ref2.apply(this, arguments);
  };
}();
/**
 * Gets the unlocked address of the given web3 instance
 *
 * @param web3 - Web3 instance
 *
 * @returns Current address
 */


exports.hasAccounts = hasAccounts;

var getCurrentAddress = /*#__PURE__*/function () {
  var _ref3 = _asyncToGenerator(function* (web3) {
    return web3.eth.getAccounts().then(a => a[0]);
  });

  return function getCurrentAddress(_x5) {
    return _ref3.apply(this, arguments);
  };
}();
/**
 * Validates the given address
 *
 * @param address
 *
 * @returns
 * true if valid, false if not
 */


exports.getCurrentAddress = getCurrentAddress;

var isValidAddress = address => rskjutils.isValidAddress(address);
/**
 * Validates the given checksum address for the given networkId
 *
 * @param address
 * @param networkId - chanetworkIdnId where checksummed address should be valid
 *
 * @returns
 * true if valid, false if not
 */


exports.isValidAddress = isValidAddress;

var isValidChecksumAddress = (address, networkId) => isValidAddress(address) && address === address.toLowerCase() || rskjutils.isValidChecksumAddress(address, networkId && networkId in _types.NetworkId ? networkId : null // ethereum networks don't use network prefix
);
/**
 * Generates checksum address
 *
 * @param address
 * @param networkId - networkId where checksummed address should be valid
 *
 * @returns
 * Checksummed address
 */


exports.isValidChecksumAddress = isValidChecksumAddress;

var toChecksumAddress = (address, networkId) => isValidAddress(address) && rskjutils.toChecksumAddress(address, networkId && networkId in _types.NetworkId ? networkId : null // ethereum networks don't use network prefix
);
/**
 * Validates the given label
 *
 * @param label - label to validate
 *
 * @returns
 * true if valid, false if not
 */


exports.toChecksumAddress = toChecksumAddress;

var isValidLabel = label => {
  if (label && !label.match('[^a-z0-9]')) {
    return true;
  }

  return false;
};
/**
 * Validates the given domain syntax
 *
 * @param domain - domain to validate
 *
 * @returns
 * true if valid, false if not
 */


exports.isValidLabel = isValidLabel;

var isValidDomain = domain => {
  var labels = domain.split('.');

  if (labels.length < 1) {
    return false;
  }

  for (var i = 0; i < labels.length; i += 1) {
    var label = labels[i];

    if (!isValidLabel(label)) {
      return false;
    }
  }

  return true;
};
/**
 * Validates the given domain TLD
 *
 * @param domain - domain to validate
 *
 * @returns
 * true if valid, false if not
 */


exports.isValidDomain = isValidDomain;

var isValidTld = domain => {
  var labels = domain.split('.');
  var tld = labels[labels.length - 1];
  return _constants.AVAILABLE_TLDS.includes(tld);
};
/**
 * Returns namehash of the given domain
 *
 * @param domain - domain to apply namehash function
 *
 * @returns
 * namehash of the given domain
 */


exports.isValidTld = isValidTld;

var namehash = domain => (0, _ethEnsNamehash.hash)(domain);
/**
 * Returns '0x' + keccak256 of the given label
 *
 * @param label - label to apply keccak256 function
 *
 * @returns
 * '0x' + keccak256 of the given label
 */


exports.namehash = namehash;

var labelhash = label => "0x".concat((0, _jsSha.keccak256)(label));

exports.labelhash = labelhash;