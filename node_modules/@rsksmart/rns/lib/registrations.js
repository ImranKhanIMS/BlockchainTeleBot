"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _composer = _interopRequireDefault(require("./composer"));

var _utils = require("./utils");

var _errors = require("./errors");

var _constants = require("./constants");

var _factories = require("./factories");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

class _default extends _composer.default {
  /**
   *
   * @param blockchainApi - current Web3 or Rsk3 instance
   * @param registry - RNS Registry Web3 Contract instance
   */
  constructor(blockchainApi, options) {
    super(blockchainApi, options);
    this.blockchainApi = blockchainApi;
  }

  _createTldOwner(tld, errorMessage, contractFactory) {
    var _this = this;

    return _asyncToGenerator(function* () {
      var nodeOwnerAddress = yield _this._contracts.registry.methods.owner((0, _utils.namehash)(tld)).call();

      if (nodeOwnerAddress === _constants.ZERO_ADDRESS) {
        _this._throw(_errors.NO_TLD_OWNER);
      }

      var hasAvailableMethod = yield (0, _utils.hasMethod)(_this.blockchainApi, nodeOwnerAddress, _constants.AVAILABLE_INTERFACE);

      if (!hasAvailableMethod) {
        _this._throw(errorMessage);
      }

      var nodeOwner = contractFactory(_this.blockchainApi, nodeOwnerAddress);
      return nodeOwner;
    })();
  }

  _searchAvailabilityByLabel(label) {
    var _this2 = this;

    return _asyncToGenerator(function* () {
      if (!(0, _utils.isValidLabel)(label)) {
        _this2._throw(_errors.INVALID_LABEL);
      }

      var availables = [];

      var promises = _constants.AVAILABLE_TLDS.map( /*#__PURE__*/function () {
        var _ref = _asyncToGenerator(function* (tld) {
          var domain = "".concat(label, ".").concat(tld);

          if (yield _this2._searchAvailabilityByDomain(domain)) {
            return domain;
          }

          return '';
        });

        return function (_x) {
          return _ref.apply(this, arguments);
        };
      }());

      availables = yield Promise.all(promises);
      return availables.filter(domain => domain !== '');
    })();
  }

  _searchAvailabilityByDomain(domain) {
    var _this3 = this;

    return _asyncToGenerator(function* () {
      if (!(0, _utils.isValidDomain)(domain)) {
        _this3._throw(_errors.INVALID_DOMAIN);
      }

      if (!(0, _utils.isValidTld)(domain)) {
        _this3._throw(_errors.SEARCH_DOMAINS_UNDER_AVAILABLE_TLDS);
      }

      var [label, tld] = domain.split('.');
      var nodeOwner = yield _this3._createTldOwner(tld, _errors.NO_AVAILABLE_METHOD, _factories.createRskOwner);
      var hash = (0, _utils.labelhash)(label);
      var available = yield nodeOwner.methods.available(hash).call();

      if (available && label.length < 5) {
        return false;
      }

      return available;
    })();
  }

  available(domain) {
    var _this4 = this;

    return _asyncToGenerator(function* () {
      yield _this4.compose();
      var {
        length
      } = domain.split('.');

      if (length === 1) {
        return _this4._searchAvailabilityByLabel(domain);
      }

      if (length === 2) {
        return _this4._searchAvailabilityByDomain(domain);
      }

      return false;
    })();
  }

}

exports.default = _default;
module.exports = exports.default;