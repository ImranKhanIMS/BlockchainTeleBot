"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _addressEncoder = require("@ensdomains/address-encoder");

var _factories = require("./factories");

var _constants = require("./constants");

var _types = require("./types");

var _composer = _interopRequireDefault(require("./composer"));

var _utils = require("./utils");

var _errors = require("./errors");

var _networks = _interopRequireDefault(require("./types/networks.json"));

var _contenthashHelper = _interopRequireDefault(require("./contenthash-helper"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

class _default extends _composer.default {
  constructor(blockchainApi, options) {
    super(blockchainApi, options);
    this.blockchainApi = blockchainApi;
    this._contenthashHelper = new _contenthashHelper.default(options);
  }

  _createResolver(node, contractFactory, noResolverError, parentNode) {
    var _this = this;

    return _asyncToGenerator(function* () {
      var resolverAddress = yield _this._contracts.registry.methods.resolver(parentNode || node).call();

      if (resolverAddress === _constants.ZERO_ADDRESS) {
        _this._throw(noResolverError || _errors.NO_RESOLVER);
      }

      var resolver = contractFactory(_this.blockchainApi, resolverAddress);
      return resolver;
    })();
  }

  _validateAddress(addr, chainId) {
    if (!chainId || [_types.ChainId.RSK, _types.ChainId.ETC, _types.ChainId.ETH, _types.ChainId.XDAI].includes(chainId)) {
      if (!(0, _utils.isValidAddress)(addr)) {
        this._throw(_errors.INVALID_ADDRESS);
      }

      if (!chainId) {
        if (!(0, _utils.isValidChecksumAddress)(addr, this.currentNetworkId)) {
          this._throw(_errors.INVALID_CHECKSUM_ADDRESS);
        }
      } else if (chainId === _types.ChainId.RSK) {
        if (!(0, _utils.isValidChecksumAddress)(addr, _types.NetworkId.RSK_MAINNET)) {
          this._throw(_errors.INVALID_CHECKSUM_ADDRESS);
        }
      } else if (!(0, _utils.isValidChecksumAddress)(addr)) {
        this._throw(_errors.INVALID_CHECKSUM_ADDRESS);
      }
    }
  }

  _getCoinTypeFromChainId(chainId) {
    var _networks$find;

    var coinType = (_networks$find = _networks.default.find(net => net.id === chainId)) === null || _networks$find === void 0 ? void 0 : _networks$find.index;

    if (coinType !== 0 && !coinType) {
      this._throw(_errors.CHAIN_ID_NOT_SUPPORTED);
    }

    return coinType;
  }

  _decodeAddressByCoinType(addr, coinType) {
    try {
      var decoded = _addressEncoder.formatsByCoinType[coinType].decoder(addr);

      return decoded;
    } catch (err) {
      this._throw(_errors.INVALID_ADDRESS);
    }

    return '';
  }

  _encodeAddressByCoinType(decodedAddr, coinType) {
    var encoded = '';

    try {
      var buff = Buffer.from(decodedAddr.replace('0x', ''), 'hex');
      encoded = _addressEncoder.formatsByCoinType[coinType].encoder(buff);
    } catch (err) {
      this._throw(_errors.INVALID_ADDRESS);
    }

    return encoded;
  }

  addr(domain) {
    var _this2 = this;

    return _asyncToGenerator(function* () {
      yield _this2.compose();
      var node = (0, _utils.namehash)(domain);
      var resolver = yield _this2._createResolver(node, _factories.createAddrResolver);
      var supportsInterface = yield resolver.methods.supportsInterface(_constants.ADDR_INTERFACE).call();

      if (!supportsInterface) {
        _this2._throw(_errors.NO_ADDR_RESOLUTION);
      }

      var addr = yield resolver.methods.addr(node).call();

      if (addr === _constants.ZERO_ADDRESS) {
        _this2._throw(_errors.NO_ADDR_RESOLUTION_SET);
      }

      return (0, _utils.toChecksumAddress)(addr, _this2.currentNetworkId);
    })();
  }

  chainAddr(domain, chainId) {
    var _this3 = this;

    return _asyncToGenerator(function* () {
      yield _this3.compose();
      var node = (0, _utils.namehash)(domain);
      var newResolver = yield _this3._createResolver(node, _factories.createNewAddrResolver);
      var supportsNewAddrInterface = yield newResolver.methods.supportsInterface(_constants.NEW_ADDR_INTERFACE).call();

      if (supportsNewAddrInterface) {
        var coinType = _this3._getCoinTypeFromChainId(chainId);

        var decodedAddr = yield newResolver.methods['addr(bytes32,uint256)'](node, coinType).call();

        if (!decodedAddr || decodedAddr === _constants.ZERO_ADDRESS || decodedAddr === '0x') {
          _this3._throw(_errors.NO_CHAIN_ADDR_RESOLUTION_SET);
        }

        var _addr = _this3._encodeAddressByCoinType(decodedAddr, coinType);

        if (!_addr || _addr === _constants.ZERO_ADDRESS) {
          _this3._throw(_errors.NO_CHAIN_ADDR_RESOLUTION_SET);
        }

        return _addr;
      }

      var chainResolver = yield _this3._createResolver(node, _factories.createChainAddrResolver);
      var supportsChainAddrInterface = yield chainResolver.methods.supportsInterface(_constants.CHAIN_ADDR_INTERFACE).call();

      if (!supportsChainAddrInterface) {
        _this3._throw(_errors.NO_CHAIN_ADDR_RESOLUTION);
      }

      var addr = yield chainResolver.methods.chainAddr(node, chainId).call();

      if (!addr || addr === _constants.ZERO_ADDRESS) {
        _this3._throw(_errors.NO_CHAIN_ADDR_RESOLUTION_SET);
      } // return checksum address just if it is a EVM blockchain address


      if ((0, _utils.isValidAddress)(addr)) {
        if (chainId === _types.ChainId.RSK) {
          return (0, _utils.toChecksumAddress)(addr, _types.NetworkId.RSK_MAINNET);
        }

        return (0, _utils.toChecksumAddress)(addr);
      }

      return addr;
    })();
  }

  setAddr(domain, addr, options, parentNode) {
    var _this4 = this;

    return _asyncToGenerator(function* () {
      yield _this4.compose();

      if (!(yield (0, _utils.hasAccounts)(_this4.blockchainApi))) {
        _this4._throw(_errors.NO_ACCOUNTS_TO_SIGN);
      }

      _this4._validateAddress(addr);

      var node = (0, _utils.namehash)(domain);
      var resolver = yield _this4._createResolver(node, _factories.createAddrResolver, undefined, parentNode);
      var contractMethod = resolver.methods.setAddr(node, addr);
      return _this4.estimateGasAndSendTransaction(contractMethod, options);
    })();
  }

  setChainAddr(domain, addr, chainId, options) {
    var _this5 = this;

    return _asyncToGenerator(function* () {
      yield _this5.compose();

      if (!(yield (0, _utils.hasAccounts)(_this5.blockchainApi))) {
        _this5._throw(_errors.NO_ACCOUNTS_TO_SIGN);
      }

      _this5._validateAddress(addr, chainId);

      var node = (0, _utils.namehash)(domain);
      var resolverAddress = yield _this5._contracts.registry.methods.resolver(node).call();

      if (resolverAddress === _constants.ZERO_ADDRESS) {
        _this5._throw(_errors.NO_RESOLVER);
      }

      var supportsChainAddrInterface = yield (0, _utils.hasMethod)(_this5.blockchainApi, resolverAddress, _constants.SET_CHAIN_ADDR_INTERFACE);
      var contractMethod;

      if (supportsChainAddrInterface) {
        var resolver = (0, _factories.createChainAddrResolver)(_this5.blockchainApi, resolverAddress);
        contractMethod = resolver.methods.setChainAddr(node, chainId, addr);
      } else {
        var _resolver = (0, _factories.createNewAddrResolver)(_this5.blockchainApi, resolverAddress);

        var coinType = _this5._getCoinTypeFromChainId(chainId);

        var decodedAddr = addr ? _this5._decodeAddressByCoinType(addr, coinType) : '0x';
        contractMethod = _resolver.methods['setAddr(bytes32,uint256,bytes)'](node, coinType, decodedAddr);
      }

      return _this5.estimateGasAndSendTransaction(contractMethod, options);
    })();
  }

  contenthash(domain) {
    var _this6 = this;

    return _asyncToGenerator(function* () {
      yield _this6.compose();
      var node = (0, _utils.namehash)(domain);
      var resolver = yield _this6._createResolver(node, _factories.createNewAddrResolver);
      var supportsInterface = yield resolver.methods.supportsInterface(_constants.CONTENTHASH_INTERFACE).call();

      if (!supportsInterface) {
        _this6._throw(_errors.NO_CONTENTHASH_INTERFACE);
      }

      var encoded = yield resolver.methods.contenthash(node).call();

      if (!encoded || encoded === '0x') {
        _this6._throw(_errors.NO_CONTENTHASH_SET);
      }

      var decoded = _this6._contenthashHelper.decodeContenthash(encoded);

      if (!(decoded === null || decoded === void 0 ? void 0 : decoded.protocolType)) {
        _this6._throw(_errors.UNSUPPORTED_CONTENTHASH_PROTOCOL);
      }

      return decoded;
    })();
  }

  setContenthash(domain, content, options) {
    var _this7 = this;

    return _asyncToGenerator(function* () {
      yield _this7.compose();

      if (!(yield (0, _utils.hasAccounts)(_this7.blockchainApi))) {
        _this7._throw(_errors.NO_ACCOUNTS_TO_SIGN);
      }

      var node = (0, _utils.namehash)(domain);
      var resolver = yield _this7._createResolver(node, _factories.createNewAddrResolver);
      var encodedContenthash = content ? _this7._contenthashHelper.encodeContenthash(content) : '0x';
      var contractMethod = resolver.methods['setContenthash(bytes32,bytes)'](node, encodedContenthash);
      return _this7.estimateGasAndSendTransaction(contractMethod, options);
    })();
  }

  setResolver(domain, resolver, options) {
    var _this8 = this;

    return _asyncToGenerator(function* () {
      yield _this8.compose();

      if (!(yield (0, _utils.hasAccounts)(_this8.blockchainApi))) {
        _this8._throw(_errors.NO_ACCOUNTS_TO_SIGN);
      }

      _this8._validateAddress(resolver);

      var domainOwner = yield _this8._contracts.registry.methods.owner((0, _utils.namehash)(domain)).call();

      if (domainOwner === _constants.ZERO_ADDRESS) {
        _this8._throw(_errors.DOMAIN_NOT_EXISTS);
      }

      var node = (0, _utils.namehash)(domain);

      var contractMethod = _this8._contracts.registry.methods.setResolver(node, resolver);

      return _this8.estimateGasAndSendTransaction(contractMethod, options);
    })();
  }

  setName(name, options) {
    var _this9 = this;

    return _asyncToGenerator(function* () {
      yield _this9.compose();

      if (!(yield (0, _utils.hasAccounts)(_this9.blockchainApi))) {
        _this9._throw(_errors.NO_ACCOUNTS_TO_SIGN);
      }

      if (!(0, _utils.isValidDomain)(name)) {
        _this9._throw(_errors.INVALID_DOMAIN);
      }

      var reverseRegistrarOwner = yield _this9._contracts.registry.methods.owner(_constants.ADDR_REVERSE_NAMEHASH).call();

      if (reverseRegistrarOwner === _constants.ZERO_ADDRESS) {
        _this9._throw(_errors.NO_REVERSE_REGISTRAR);
      }

      var hasSetNameMethod = yield (0, _utils.hasMethod)(_this9.blockchainApi, reverseRegistrarOwner, _constants.SET_NAME_INTERFACE);

      if (!hasSetNameMethod) {
        _this9._throw(_errors.NO_SET_NAME_METHOD);
      }

      var reverseRegistrar = (0, _factories.createReverseRegistrar)(_this9.blockchainApi, reverseRegistrarOwner);
      var contractMethod = reverseRegistrar.methods.setName(name);
      return _this9.estimateGasAndSendTransaction(contractMethod, options);
    })();
  }

  name(address) {
    var _this10 = this;

    return _asyncToGenerator(function* () {
      yield _this10.compose();
      var convertedAddress = address.substring(2).toLowerCase(); // remove '0x'

      var node = (0, _utils.namehash)("".concat(convertedAddress, ".addr.reverse"));
      var resolver = yield _this10._createResolver(node, _factories.createNameResolver, _errors.NO_REVERSE_RESOLUTION_SET);
      var supportsInterface = yield resolver.methods.supportsInterface(_constants.NAME_INTERFACE).call();

      if (!supportsInterface) {
        _this10._throw(_errors.NO_NAME_RESOLUTION);
      }

      var name = yield resolver.methods.name(node).call();

      if (!name) {
        _this10._throw(_errors.NO_REVERSE_RESOLUTION_SET);
      }

      return name;
    })();
  }

}

exports.default = _default;
module.exports = exports.default;