"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _errors = require("./errors");

var _constants = require("./constants");

var _composer = _interopRequireDefault(require("./composer"));

var _utils = require("./utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

class _default extends _composer.default {
  constructor(blockchainApi, _resolutions, options) {
    super(blockchainApi, options);
    this._resolutions = _resolutions;
  }

  _setSubnodeOwner(node, label, owner, options) {
    var contractMethod = this._contracts.registry.methods.setSubnodeOwner(node, (0, _utils.labelhash)(label), owner);

    return this.estimateGasAndSendTransaction(contractMethod, options);
  }

  _validateDomainAndLabel(domain, label) {
    if (!(0, _utils.isValidDomain)(domain)) {
      this._throw(_errors.INVALID_DOMAIN);
    }

    if (!(0, _utils.isValidTld)(domain)) {
      this._throw(_errors.SEARCH_DOMAINS_UNDER_AVAILABLE_TLDS);
    }

    if (!(0, _utils.isValidLabel)(label)) {
      this._throw(_errors.INVALID_LABEL);
    }
  }

  _validateAddress(addr) {
    if (!(0, _utils.isValidAddress)(addr)) {
      this._throw(_errors.INVALID_ADDRESS);
    }

    if (!(0, _utils.isValidChecksumAddress)(addr, this.currentNetworkId)) {
      this._throw(_errors.INVALID_CHECKSUM_ADDRESS);
    }
  }
  /**
   * Checks if the given label subdomain is available under the given domain tree
   *
   * @throws SEARCH_DOMAINS_UNDER_AVAILABLE_TLDS if the given domain is not a domain under valid TLDs - KB009
   * @throws INVALID_DOMAIN if the given domain is empty, is not alphanumeric or if has uppercase characters - KB010
   * @throws INVALID_LABEL if the given label is empty, is not alphanumeric or if has uppercase characters - KB011
   * @throws DOMAIN_NOT_EXISTS if the given domain does not exists - KB012
   *
   * @param domain - Parent .rsk domain. ie: wallet.rsk
   * @param label - Subdomain to check if is available. ie: alice
   *
   * @returns
   * true if available, false if not
   */


  available(domain, label) {
    var _this = this;

    return _asyncToGenerator(function* () {
      yield _this.compose();

      _this._validateDomainAndLabel(domain, label);

      var domainOwner = yield _this._contracts.registry.methods.owner((0, _utils.namehash)(domain)).call();

      if (domainOwner === _constants.ZERO_ADDRESS) {
        _this._throw(_errors.DOMAIN_NOT_EXISTS);
      }

      var node = (0, _utils.namehash)("".concat(label, ".").concat(domain));
      var owner = yield _this._contracts.registry.methods.owner(node).call();
      return owner === _constants.ZERO_ADDRESS;
    })();
  }
  /**
   * Sets a subdomain owner. If the subdomain exists, sets the new owner, if not, creates the subdomain and sets the owner.
   *
   * @throws SEARCH_DOMAINS_UNDER_AVAILABLE_TLDS if the given domain is not a domain under valid TLDs - KB009
   * @throws INVALID_DOMAIN if the given domain is empty, is not alphanumeric or if has uppercase characters - KB010
   * @throws INVALID_LABEL if the given label is empty, is not alphanumeric or if has uppercase characters - KB011
   * @throws DOMAIN_NOT_EXISTS if the given domain does not exists - KB012
   * @throws NO_ACCOUNTS_TO_SIGN if the given blockchain api instance does not have associated accounts to sign the transaction - KB015
   * @throws INVALID_ADDRESS if the given owner address is invalid - KB017
   * @throws INVALID_CHECKSUM_ADDRESS if the given owner address has an invalid checksum - KB019
   *
   * @param domain - Parent .rsk domain. ie: wallet.rsk
   * @param label - Subdomain to register. ie: alice
   * @param owner - The owner of the new subdomain
   * @param options - Custom configs to be used when submitting the transaction
   *
   * @returns Transaction hash
   */


  setOwner(domain, label, owner, options) {
    var _this2 = this;

    return _asyncToGenerator(function* () {
      yield _this2.compose();

      if (!(yield (0, _utils.hasAccounts)(_this2.blockchainApi))) {
        _this2._throw(_errors.NO_ACCOUNTS_TO_SIGN);
      }

      _this2._validateDomainAndLabel(domain, label);

      _this2._validateAddress(owner);

      var domainOwner = yield _this2._contracts.registry.methods.owner((0, _utils.namehash)(domain)).call();

      if (domainOwner === _constants.ZERO_ADDRESS) {
        _this2._throw(_errors.DOMAIN_NOT_EXISTS);
      }

      var node = (0, _utils.namehash)("".concat(domain));
      return _this2._setSubnodeOwner(node, label, owner, options);
    })();
  }
  /**
   * Creates a new subdomain under the given domain tree if it is available, and sets its resolution if addr is provided.
   * It could send one, two or three transactions based on the value of the sent parameters.
   *
   * @throws SEARCH_DOMAINS_UNDER_AVAILABLE_TLDS if the given domain is not a domain under valid TLDs - KB009
   * @throws INVALID_DOMAIN if the given domain is empty, is not alphanumeric or if has uppercase characters - KB010
   * @throws INVALID_LABEL if the given label is empty, is not alphanumeric or if has uppercase characters - KB011
   * @throws DOMAIN_NOT_EXISTS if the given domain does not exists - KB012
   * @throws SUBDOMAIN_NOT_AVAILABLE if the given domain is already owned - KB016
   * @throws NO_ACCOUNTS_TO_SIGN if the given blockchain api instance does not have associated accounts to sign the transaction - KB015
   * @throws INVALID_ADDRESS if the given owner or address resolution is invalid - KB017
   * @throws INVALID_CHECKSUM_ADDRESS if the given owner address or resolution has an invalid checksum - KB019
   *
   * @param domain - Parent .rsk domain. ie: wallet.rsk
   * @param label - Subdomain to register. ie: alice
   * @param owner - The owner of the new subdomain. If not provided, the address who executes the tx will be the owner
   * @param addr - The address to be set as resolution of the new subdomain
   * @param options - Custom configs to be used when submitting the transaction
   *
   * @returns Transaction hash of the latest transaction
   */


  create(domain, label, owner, addr, options) {
    var _this3 = this;

    return _asyncToGenerator(function* () {
      yield _this3.compose();

      if (!(yield (0, _utils.hasAccounts)(_this3.blockchainApi))) {
        _this3._throw(_errors.NO_ACCOUNTS_TO_SIGN);
      }

      _this3._validateDomainAndLabel(domain, label);

      if (owner) {
        _this3._validateAddress(owner);
      }

      if (addr) {
        _this3._validateAddress(addr);
      }

      var domainOwner = yield _this3._contracts.registry.methods.owner((0, _utils.namehash)(domain)).call();

      if (domainOwner === _constants.ZERO_ADDRESS) {
        _this3._throw(_errors.DOMAIN_NOT_EXISTS);
      }

      if (!(yield _this3.available(domain, label))) {
        _this3._throw(_errors.SUBDOMAIN_NOT_AVAILABLE);
      }

      var node = (0, _utils.namehash)("".concat(domain));
      var sender;

      if (options && options.from) {
        sender = options.from;
      } else {
        try {
          sender = yield (0, _utils.getCurrentAddress)(_this3.blockchainApi);
        } catch (_unused) {
          _this3._throw(_errors.NO_ACCOUNTS_TO_SIGN);
        }
      }

      sender = sender;

      if (!addr) {
        return _this3._setSubnodeOwner(node, label, owner || sender, options);
      }

      if (!owner || owner.toLowerCase() === sender.toLowerCase()) {
        // submits just two transactions
        yield _this3._setSubnodeOwner(node, label, sender, options);
        return _this3._resolutions.setAddr("".concat(label, ".").concat(domain), addr, options, node);
      } // needs to submit three txs


      yield _this3._setSubnodeOwner(node, label, sender, options);
      yield _this3._resolutions.setAddr("".concat(label, ".").concat(domain), addr, options, node);
      return _this3._setSubnodeOwner(node, label, owner, options);
    })();
  }

}

exports.default = _default;
module.exports = exports.default;