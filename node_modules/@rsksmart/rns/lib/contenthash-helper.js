"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _contentHash = _interopRequireDefault(require("content-hash"));

var _bs = _interopRequireDefault(require("bs58"));

var _ErrorWrapper = _interopRequireDefault(require("./errors/ErrorWrapper"));

var _errors = require("./errors");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// most of te code has been copied from https://github.com/ensdomains/ui/blob/b7d36a2a96f6c991a8e109f91f9bd6fb6b1f4589/src/utils/contents.js
class _default extends _ErrorWrapper.default {
  constructor(options) {
    super(options && options.lang);
  }

  decodeContenthash(encoded) {
    var decoded = '';
    var protocolType = '';

    try {
      decoded = _contentHash.default.decode(encoded);

      var codec = _contentHash.default.getCodec(encoded);

      if (codec === 'ipfs-ns') {
        protocolType = 'ipfs';
      } else if (codec === 'ipns-ns') {
        decoded = _bs.default.decode(decoded).slice(2).toString();
        protocolType = 'ipns';
      } else if (codec === 'swarm-ns') {
        protocolType = 'bzz';
      } else if (codec === 'onion') {
        protocolType = 'onion';
      } else if (codec === 'onion3') {
        protocolType = 'onion3';
      } else {
        this._throw(_errors.UNSUPPORTED_CONTENTHASH_PROTOCOL);
      }
    } catch (e) {
      this._throw(_errors.UNSUPPORTED_CONTENTHASH_PROTOCOL);
    }

    return {
      decoded,
      protocolType
    };
  }

  encodeContenthash(text) {
    var content = '';
    var contentType = '';

    if (text) {
      var matched = text.match(/^(ipfs|ipns|bzz|onion|onion3):\/\/(.*)/) || text.match(/\/(ipfs)\/(.*)/);

      if (matched) {
        [, contentType, content] = matched;
      }

      try {
        if (contentType === 'ipfs') {
          if (content.length >= 4) {
            return "0x".concat(_contentHash.default.encode('ipfs-ns', content));
          }
        } else if (contentType === 'ipns') {
          var bs58content = _bs.default.encode(Buffer.concat([Buffer.from([0, content.length]), Buffer.from(content)]));

          return "0x".concat(_contentHash.default.encode('ipns-ns', bs58content));
        } else if (contentType === 'bzz') {
          if (content.length >= 4) {
            return "0x".concat(_contentHash.default.fromSwarm(content));
          }
        } else if (contentType === 'onion') {
          if (content.length === 16) {
            return "0x".concat(_contentHash.default.encode('onion', content));
          }
        } else if (contentType === 'onion3') {
          if (content.length === 56) {
            return "0x".concat(_contentHash.default.encode('onion3', content));
          }
        } else {
          this._throw(_errors.UNSUPPORTED_CONTENTHASH_PROTOCOL);
        }
      } catch (err) {
        this._throw(_errors.UNSUPPORTED_CONTENTHASH_PROTOCOL);
      }
    }

    return '';
  }

}

exports.default = _default;
module.exports = exports.default;