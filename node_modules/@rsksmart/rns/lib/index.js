"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _errors = require("./errors");

var _resolutions = _interopRequireDefault(require("./resolutions"));

var _registrations = _interopRequireDefault(require("./registrations"));

var _subdomains = _interopRequireDefault(require("./subdomains"));

var _composer = _interopRequireDefault(require("./composer"));

var utils = _interopRequireWildcard(require("./utils"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

/**
 * RNS JavaScript library.
 */
class _default extends _composer.default {
  /**
   * Create RNS library.
   *
   * @remarks
   * If the blockchain api points to RSK Mainnet or RSK Testnet, no options are required. Contract addresses are detected automatically.
   *
   * @param blockchainApi - Web3 or Rsk3 instance
   * @param options - Overrides network defaults. Optional on RSK Mainnet and RSK Testnet, required for other networks.
   */
  constructor(blockchainApi, options) {
    super(blockchainApi, options);
    this._resolutions = new _resolutions.default(this.blockchainApi, options);
    this._subdomains = new _subdomains.default(this.blockchainApi, this._resolutions, options);
    this._registrations = new _registrations.default(this.blockchainApi, options);
  }
  /**
   * RNS suite contract instances.
   *
   * @throws LIBRARY_NOT_COMPOSED if the library was not previously composed with compose method - KB004.
   *
   * @returns Web3 Contract instances of RNS public smart contracts
   */


  get contracts() {
    if (!this._contracts) {
      this._throw(_errors.LIBRARY_NOT_COMPOSED);
    }

    return this._contracts;
  }
  /**
   * Get address of a given domain and chain. If chainId is not provided, it resolves current blockchain address.
   *
   * @throws NO_RESOLVER when the domain doesn't have resolver - KB003.
   * @throws NO_ADDR_RESOLUTION_SET if the resolution hasn't been set yet - KB001.
   * @throws NO_ADDR_RESOLUTION it has an invalid resolver - KB002.
   * @throws NO_CHAIN_ADDR_RESOLUTION_SET if `chainId` provided and the resolution hasn't been set yet - KB007.
   * @throws NO_CHAIN_ADDR_RESOLUTION `chainId` provided and it has an invalid resolver - KB006.
   *
   * @param domain - Domain to be resolved
   * @param chainId - chain identifier listed in SLIP44 (https://github.com/satoshilabs/slips/blob/master/slip-0044.md)
   *
   * @returns checksummed address resolution of the given domain and chainId (if provided)
   */


  addr(domain, chainId) {
    var _this = this;

    return _asyncToGenerator(function* () {
      if (!chainId) {
        return _this._resolutions.addr(domain);
      }

      return _this._resolutions.chainAddr(domain, chainId);
    })();
  }
  /**
   * Set address resolution of a given domain in a given chain.
   *
   * @throws NO_ADDR_RESOLUTION it has an invalid resolver - KB002.
   * @throws NO_RESOLVER when the domain doesn't have resolver - KB003.
   * @throws NO_ACCOUNTS_TO_SIGN if the given blockchain api instance does not have associated accounts to sign the transaction - KB015
   * @throws INVALID_ADDRESS if the given addr is invalid - KB017
   * @throws INVALID_CHECKSUM_ADDRESS if the given addr has an invalid checksum - KB019
   * @throws NO_SET_CHAIN_ADDR if the multichain resolver does not implement setName method - KB024
   *
   * @param domain - Domain to set resolution
   * @param addr - Address to be set as the resolution of the given domain
   * @param chainId - Should match one of the listed in SLIP44 (https://github.com/satoshilabs/slips/blob/master/slip-0044.md)
   * @param options - Custom configs to be used when submitting the transaction
   *
   * @returns Transaction hash
   */


  setAddr(domain, addr, chainId, options) {
    if (!chainId) {
      return this._resolutions.setAddr(domain, addr, options);
    }

    return this._resolutions.setChainAddr(domain, addr, chainId, options);
  }
  /**
   * Get decoded contenthash of a given domain.
   *
   * @throws NO_RESOLVER when the domain doesn't have resolver - KB003.
   * @throws NO_CONTENTHASH_INTERFACE if has an invalid resolver - KB025.
   * @throws NO_CONTENTHASH_SET it there is not contenthash resolution set - KB026.
   * @throws UNSUPPORTED_CONTENTHASH_PROTOCOL if the contenthash could not be decoded - KB027.
   *
   * @param domain - Domain to be resolved
   *
   * @returns
   * Decoded content and protocolType associated to the given domain
   */


  contenthash(domain) {
    return this._resolutions.contenthash(domain);
  }
  /**
   * Set contenthash of a given domain.
   *
   * @throws NO_ACCOUNTS_TO_SIGN if the given blockchain api instance does not have associated accounts to sign the transaction - KB015
   * @throws NO_RESOLVER when the domain doesn't have resolver - KB003.
   * @throws UNSUPPORTED_CONTENTHASH_PROTOCOL if the contenthash could not be encoded - KB027.
   *
   * @param domain - Domain to be resolved
   * @param content - Content to be associated to the given domain. Must be decoded, the library will encode and save it.
   *
   * @returns Transaction hash
   */


  setContenthash(domain, content, options) {
    return this._resolutions.setContenthash(domain, content, options);
  }
  /**
   * Set resolver of a given domain.
   *
   * @throws NO_ACCOUNTS_TO_SIGN if the given blockchain api instance does not have associated accounts to sign the transaction - KB015
   * @throws INVALID_ADDRESS if the given resolver address is invalid - KB017
   * @throws INVALID_CHECKSUM_ADDRESS if the given resolver address has an invalid checksum - KB019
   * @throws DOMAIN_NOT_EXISTS if the given domain does not exists - KB012
   *
   * @param domain - Domain to set resolver
   * @param resolver - Address to be set as the resolver of the given domain
   * @param options - Custom configs to be used when submitting the transaction
   *
   * @returns Transaction hash
   */


  setResolver(domain, resolver, options) {
    return this._resolutions.setResolver(domain, resolver, options);
  }
  /**
   * Reverse lookup: get name of a given address.
   *
   * @throws NO_REVERSE_RESOLUTION_SET when the domain has not set the reverse resolution yet - KB014.
   * @throws NO_NAME_RESOLUTION when the domain has an invalid name resolver - KB013.
   *
   * @param address - address to be resolved
   *
   * @returns Domain or subdomain associated to the given address.
   */


  reverse(address) {
    var _this2 = this;

    return _asyncToGenerator(function* () {
      return _this2._resolutions.name(address);
    })();
  }
  /**
   * Set reverse resolution with the given name for the current address.
   *
   * @param name - Name to be set as the reverse resolution of the current address
   * @param options - Custom configs to be used when submitting the transaction
   *
   * @throws NO_ACCOUNTS_TO_SIGN if the given blockchain api instance does not have associated accounts to sign the transaction - KB015
   * @throws INVALID_DOMAIN if the given domain is empty, is not alphanumeric or if has uppercase characters - KB010
   * @throws NO_REVERSE_REGISTRAR if there is no owner for `addr.reverse` node - KB022
   * @throws NO_SET_NAME_METHOD if reverse registrar does not implement `setName` method - KB023
   *
   * @returns Transaction hash
   */


  setReverse(name, options) {
    return this._resolutions.setName(name, options);
  }
  /**
   * Check if given domain is available or if there are any availability for the given label.
   *
   * @param domain - Domain or label to check availability
   *
   * @throws SEARCH_DOMAINS_UNDER_AVAILABLE_TLDS if the given domain is under an invalid tld
   * @throws INVALID_DOMAIN if the given parameter is a domain and is not alphanumeric
   * @throws INVALID_LABEL if the given parameter is a label and is not alphanumeric
   * @throws NO_AVAILABLE_METHOD when the TLD owner does not implement the available method
   * @throws NO_TLD_OWNER when the TLD does not has an owner
   *
   * @returns
   * True if the domain is available, false if not, or an array of available domains under possible TLDs if the parameter is a label
   */


  available(domain) {
    var _this3 = this;

    return _asyncToGenerator(function* () {
      return _this3._registrations.available(domain);
    })();
  }
  /**
   * Set of subdomains related methods
   *
   * @returns Object with subdomains related methods ready to use.
   */


  get subdomains() {
    return this._subdomains;
  }
  /**
   * Set of subdomains related methods
   *
   * @returns Object with subdomains related methods ready to use.
   */

  /* eslint-disable class-methods-use-this */


  get utils() {
    return {
      hasAccounts: utils.hasAccounts,
      hasMethod: utils.hasMethod,
      isValidLabel: utils.isValidLabel,
      isValidDomain: utils.isValidDomain,
      isValidTld: utils.isValidTld,
      namehash: utils.namehash,
      labelhash: utils.labelhash,
      isValidAddress: utils.isValidAddress,
      isValidChecksumAddress: utils.isValidChecksumAddress,
      toChecksumAddress: utils.toChecksumAddress
    };
  }

}

exports.default = _default;
module.exports = exports.default;